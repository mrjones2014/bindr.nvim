M.setup()                                                              *M.setup*


M.find({opts})                                                          *M.find*
Find items using vim.ui.select()

Parameters: ~
{opts}  (LegendaryFindOpts)  @overload fun()


M.keymap({keymap})                                                    *M.keymap*
Bind a *single keymap*

Parameters: ~
{keymap}  (table)


M.command({command})                                                 *M.command*
Bind a *single command*

Parameters: ~
{command}  (table)


M.func({function})                                                      *M.func*
Bind a *single function*

Parameters: ~
{function}  (table)


M.autocmds({aus})                                                   *M.autocmds*
@diagnostic enable: undefined-doc-param
Bind a *list of* autocmds and/or augroups

Parameters: ~
{aus}  (Autocmd|Augroup[])


M.autocmd({au})                                                      *M.autocmd*
Bind a *single autocmd/augroup*

Parameters: ~
{au}  (Autocmd|Augroup)


M.bind_keymap()                                                  *M.bind_keymap*
@deprecated


M.bind_keymaps()                                                *M.bind_keymaps*
@deprecated


M.bind_command()                                                *M.bind_command*
@deprecated


M.bind_commands()                                              *M.bind_commands*
@deprecated


M.bind_function()                                              *M.bind_function*
@deprecated


M.bind_functions()                                            *M.bind_functions*
@deprecated


M.bind_autocmds()                                              *M.bind_autocmds*
@deprecated


M.bind_whichkey()                                              *M.bind_whichkey*
@deprecated


M.parse_whichkey()                                            *M.parse_whichkey*
@deprecated


M.whichkey_listen()                                          *M.whichkey_listen*
@deprecated


M.mode({mode})                                                          *M.mode*
Return a `LegendaryItemFilter` that filters items
by the specified mode

Parameters: ~
{mode}  (string)

Returns: ~
{LegendaryItemFilter}


M.current_mode()                                                *M.current_mode*
Return a `LegendaryItemFilter` that filters items
by the current mode

Returns: ~
{LegendaryItemFilter}


M.keymaps()                                                          *M.keymaps*
Filter to only show keymaps

Returns: ~
{LegendaryItemFilter}


M.commands()                                                        *M.commands*
Filter to only show commands

Returns: ~
{LegendaryItemFilter}


M.autocmds()                                                        *M.autocmds*
Filter to only show autocmds

Returns: ~
{LegendaryItemFilter}


M.funcs()                                                              *M.funcs*
Filter to only show functions

Returns: ~
{LegendaryItemFilter}


M.lazy({fn})                                                            *M.lazy*
Return a function with statically set arguments.

Parameters: ~
{fn}  (function)  The function to execute lazily
@param ... any The arguments to pass to `fn` when called

Returns: ~
{function}


M.lazy_required_fn({module_name}, {fn_name})
Return a function which lazily `require`s a module and
calls a function from it. Functions nested within tables
may be accessed using dot-notation, i.e.
`lazy_required_fn('module_name', 'some.nested.fn', some_argument)`

Parameters: ~
{module_name}  (string)  The module to `require`
{fn_name}      (string)  The table path to the function
@param ... any The arguments to pass to the function

Returns: ~
{function}


M.split_then({fn})                                                *M.split_then*
Return a function that creates a new horizontal
split, then calls the given function.

Parameters: ~
{fn}  (function)  The function to call after creating a spli

Returns: ~
{function}


M.vsplit_then({fn})                                              *M.vsplit_then*
Return a function that creates a new vertical
split, then calls the given function.

Parameters: ~
{fn}  (function)  The function to call after creating a spli

Returns: ~
{function}


M.is_keymap({keymap})                                              *M.is_keymap*
Check if an item is a Keymap

Parameters: ~
{keymap}  (LegendaryItem)

Returns: ~
{boolean}


M.is_command({cmd})                                               *M.is_command*
Check if an item is a Command

Parameters: ~
{cmd}  (LegendaryItem)

Returns: ~
{boolean}


M.is_augroup({au})                                                *M.is_augroup*
Check if an item is an Augroup

Parameters: ~
{au}  (LegendaryItem)

Returns: ~
{boolean}


M.is_autocmd({autocmd})                                           *M.is_autocmd*
Check if an item is an Autocmd

Parameters: ~
{autocmd}  (LegendaryItem)

Returns: ~
{boolean}


M.is_augroup_or_autocmd({au_or_autocmd})               *M.is_augroup_or_autocmd*
Check if an item is an Augroup or Autocmd

Parameters: ~
{au_or_autocmd}  (LegendaryItem)

Returns: ~
{boolean}


M.is_function({func})                                            *M.is_function*
Check if an item is a Function

Parameters: ~
{func}  (LegendaryItem)

Returns: ~
{boolean}


M.is_visual_mode({mode_str})                                  *M.is_visual_mode*
Check if the given mode string indicates a visual mode or a sub-mode of visual mode.
Defaults to `vim.fn.mode()`

Parameters: ~
{mode_str}  (string|nil)

Returns: ~
{boolean}  @overload fun()


Marks                                                                    *Marks*


M.get_marks()                                                      *M.get_marks*
@field [1] integer
@field [2] integer
@field [3] integer
@field [4] integer
Get visual marks in format {start_line, start_col, end_line, end_col}

Returns: ~
{Marks}


M.set_marks({marks})                                               *M.set_marks*
Set visual marks from a table in the forma
{start_line, start_col, end_line, end_col}

Parameters: ~
{marks}  (Marks)  the marks to se


M.table_from_vimscript({vimscript_str}, {description})
Parse a vimscript mapping command (e.g. `vnoremap <silent> <leader>f :SomeCommand<CR>`)
and return a `legendary.nvim` keymapping table that can be used in your configuration.

Parameters: ~
{vimscript_str}  (string)
{description}    (string)

Returns: ~
{table}


LegendaryItemFormatter                                  *LegendaryItemFormatter*

Type: ~
fun(items:LegendaryItem[],mode:string):string[]


M.default_format({item})                                      *M.default_format*
Default forma

Parameters: ~
{item}  (LegendaryItem)

Returns: ~
{string[]}


M.compute_padding({items}, {mode}, {formatter})
Format items

Parameters: ~
{items}      (LegendaryItem[])
{mode}       (string)
{formatter}  (LegendaryItemFormatter)


M.format_item({item}, {formatter}, {padding}, {mode})
Format a single item, meant to be used in `vim.ui.select()`

Parameters: ~
{item}       (LegendaryItem)
{formatter}  (LegendaryItemFormatter)
{padding}    (integer[])
{mode}       (string)

Returns: ~
{string}


M.parse_whichkey({which_key_tbls}, {which_key_opts}, {do_binding})
Take which-key.nvim tables
and parse them into legendary.nvim tables

Parameters: ~
{which_key_tbls}  (table[])
{which_key_opts}  (table)
{do_binding}      (boolean)  whether to bind the keymaps or let which-key handle i

Returns: ~
{LegendaryItem[]}


M.bind_whichkey({wk_tbls}, {wk_opts}, {do_binding})
Bind a which-key.nvim table with legendary.nvim

Parameters: ~
{wk_tbls}     (table)
{wk_opts}     (table)
{do_binding}  (boolean)  whether to bind the keymaps or let which-key handle i


M.whichkey_listen()                                          *M.whichkey_listen*
Enable auto-registering of which-key.nvim tables
with legendary.nvim


vim:tw=78:ts=8:noet:ft=help:norl:
